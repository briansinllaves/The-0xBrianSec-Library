# Repurposing Malware

Repurposing malware is the process of taking existing malicious code and adapting it for new objectives, targets, or operational environments. This practice is common among both threat actors and red teamers, as it allows for rapid development and deployment of tools without starting from scratch. Repurposing can range from simple configuration changes to significant codebase modifications.

## Understanding the Original Malware

Before repurposing, it is essential to thoroughly analyze the original malware. This involves reverse engineering the binary or reviewing the source code (if available) to understand its architecture, capabilities, and limitations. The goal is to know exactly what you are modifying and what risks are introduced.

Key aspects to examine include:

* **Command and Control (C2) Mechanisms:**
  Determine whether the malware uses centralized HTTP(S), DNS tunneling, TOR hidden services, peer-to-peer mesh networking, or custom binary protocols. Understanding encryption methods, beacon intervals, and fallback channels is critical to knowing how resilient the malware is.

* **Persistence Methods:**
  Look for persistence via registry run keys, scheduled tasks, cron jobs, system services, kernel drivers, or DLL hijacking. Repurposing often means adapting persistence to fit a different privilege level or operating system.

* **Payload Delivery:**
  Identify if the malware uses process hollowing, reflective DLL injection, APC (Asynchronous Procedure Call) injection, or exploiting specific CVEs. Some delivery methods are noisy, others stealthy. Choosing which to keep or replace depends on operational goals.

* **Detection Footprint:**
  Catalog signatures (YARA rules, hash values, strings) and behavioral indicators (mutex names, file paths, network URIs). Knowing what defenders already detect is vital for deciding what to rework.

## Adapting to New Objectives

Repurposing often involves changing the intent or functionality of the malware. Instead of rewriting the entire program, an operator can surgically replace or extend functionality.

Common adaptations include:

* **Modifying Payloads:**
  Swap in a different module (e.g., replace a ransomware encryptor with a data wiper, add a credential stealer or clipboard monitor). Modularizing payloads allows for flexible, campaign-specific usage.

* **Changing C2 Infrastructure:**
  Update hardcoded domains, IP addresses, or certificates. Many repurposed malware strains get caught simply because the operator forgot to replace expired or burned infrastructure. Encryption key changes are also mandatory.

* **Altering Persistence:**
  Swap techniques to match the target OS or environment. For example, use `systemd` services on Linux targets instead of Windows scheduled tasks. Adjust permissions to avoid detection by endpoint controls.

* **Customizing Evasion Techniques:**
  Replace outdated packers with custom obfuscators. Add sandbox checks, time bombs (delayed execution), or API call obfuscation to resist automated analysis.

## Rebranding and Theming

Attribution avoidance and campaign differentiation require rebranding. Analysts often tie malware families together through unique artifacts, so those must be altered.

* **Renaming Files and Functions:**
  Change strings inside the binary, update DLL exports, rename resource sections.

* **Altering Metadata:**
  Modify PE headers, compiler timestamps, build paths, and embedded icons. Even small metadata changes can break YARA rules.

* **Changing Network Indicators:**
  Adjust HTTP User-Agent headers, cookie names, URI paths, and encryption padding. Mimic benign traffic patterns (e.g., cloud storage APIs, Slack/Discord traffic).

## Testing and Validation

Repurposed malware must be validated in isolated environments:

* **Sandbox Testing:** Check functionality under various OS builds.
* **Debugging/Tracing:** Use tools like x64dbg, Process Monitor, Wireshark to verify stealth and performance.
* **IOC Review:** Ensure old indicators are removed and replaced.
* **Red Team QA:** Run in an environment similar to target to confirm compatibility.

## Ethical and Legal Considerations

Repurposing malware carries risk. Legal frameworks (e.g., CFAA in the U.S.) mean unauthorized deployment is criminal. For red team or academic research:

* Always have written authorization.
* Contain activity to labs or test ranges.
* Document modifications to prevent accidental misuse.

---

# Rewriting Malware

Rewriting malware involves taking the core techniques of existing malicious software and implementing them in a new codebase. This provides stealth, maintainability, and platform flexibility. Unlike repurposing, rewriting doesn’t carry over old code—it carries over old ideas.

## Motivations for Rewriting

* **Evading Detection:**
  Defenders write YARA rules, machine-learning models, and AV signatures against known families. Freshly written malware with different code structure avoids these controls.

* **Portability:**
  Legacy malware may only target Windows x86. A rewrite can add support for Linux, macOS, or ARM64 systems used in IoT and mobile.

* **Maintainability:**
  Old malware often has spaghetti code. Rewriting lets developers introduce modular classes, modern languages (C++, Rust, Go), and improved error handling.

* **Feature Expansion:**
  Operators can embed updated persistence methods, modern encryption (AES-GCM instead of XOR), and integration with new C2 frameworks.

## Planning the Rewrite

* Define operational goals. Example: stealth vs. speed.
* Separate architecture into components: loader, persistence, C2, payload modules.
* Decide on language (C for raw performance, C++/Rust for modularity, Go for cross-compilation).
* Set rules for modularity: plugin-based design allows adding features without rewriting the core.

## Implementing Core Functionality

* **C2 Communication:**
  Add multiple channels (HTTPS, DNS, SMB pipes, covert ICMP). Provide fallback servers to avoid sinkholing.

* **Persistence:**
  Build persistence templates per-OS. Allow runtime flags to enable/disable specific methods.

* **Payload Execution:**
  Implement reflective loading, APC injection, and in-memory execution. Optionally embed interpreters for PowerShell, Python, or Lua.

* **Modular Payloads:**
  Design as plugins: keylogger.dll, screenshot.so, crypto\_ransom.go. Loadable at runtime via C2 commands.

## Evasion and Anti-Analysis

* **Obfuscation:**
  Use polymorphic builds—each compilation changes string encryption keys, mutex names, and control-flow.
* **Dynamic API Resolution:**
  Resolve syscalls via hashes instead of imports.
* **Anti-Debugging:**
  Detect breakpoints, sleep-skipping, VM artifacts (e.g., VMware MAC prefixes).
* **Randomization:**
  Rotate network indicators per build to make attribution harder.

## Testing and Quality Assurance

* **Functional Testing:** Confirm all modules work.
* **Detection Testing:** Run against AV/EDR to benchmark stealth.
* **Performance Testing:** Measure CPU/memory usage to avoid crashes on target.
* **Peer Review:** Have trusted teammates check for OPSEC mistakes (hardcoded paths, debug strings).

## Documentation and Version Control

* Maintain a private Git repo.
* Track commits for each feature, including build configurations.
* Store IOC differences per release to understand detection evolution.
* Document both operational and ethical constraints.

## Responsible Use

Rewriting malware is only valid for controlled use:

* Red teaming under client authorization.
* Security research for defensive tool improvement.
* Academic study in controlled labs.

Unauthorized deployment remains illegal.

---

By understanding both **repurposing** and **rewriting**, security professionals can better anticipate attacker tradecraft, design stronger detection methods, and responsibly simulate advanced threats.

---

