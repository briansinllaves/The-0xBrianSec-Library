# SpeedDev - Malware Builder Framework

## How to Use the SpeedDev Framework

SpeedDev is a modular malware builder framework designed for rapid development, testing, and customization of offensive tooling. Each directory and file represents a reusable component or technique. Here’s how to leverage the framework:

---

### 1. Core Concepts

- **Modularity:** Each `.h` file is a self-contained class or function set for a specific technique (e.g., AV evasion, process injection).
- **Mix & Match:** Combine modules as needed for your payload or implant.
- **Customization:** Edit or extend modules to fit your target environment or OPSEC needs.

---

### 2. Using CodeClasses

#### CPlusPlus

- **AV_Evasion:**  
  Import headers like `av_bypass.h`, `edr_unhook.h`, or `syscall_spoofing.h` to add anti-AV/EDR features.  
  Example:  
  ```cpp
  #include "AV_Evasion/av_bypass.h"
  #include "AV_Evasion/syscall_spoofing.h"
  // Use provided functions to patch AV hooks or spoof syscalls.
  ```

- **Crypto:**  
  Use `aes256.h`, `rc4.h`, or `blowfish.h` to encrypt payloads, C2 traffic, or configuration data.  
  Example:  
  ```cpp
  #include "Crypto/aes256.h"
  std::string encrypted = aes256_encrypt(data, key);
  ```

- **Processes:**  
  Use `process_utils.h` and `memory_injection.h` for process enumeration, injection, and thread hijacking.

- **Tokens:**  
  Use `token_impersonation.h` and `privilege_escalation.h` to steal or duplicate tokens for privilege escalation.

---

### 3. Credential Theft

- **lsass_dump.h:**  
  Dump LSASS memory for credential extraction.
- **mimikatz_loader.h:**  
  Reflectively load and execute Mimikatz in-memory.

---

### 4. Defensive Evasion

- **amsi_patch.h:**  
  Patch AMSI in memory to bypass script scanning.
- **edr_hooking.h:**  
  Unhook or patch EDR hooks.
- **process_tampering.h:**  
  Masquerade your process as a legitimate one.

---

### 5. Dumpers & Enumerators

- **Dumpers:**  
  Extract registry hives, clipboard data, or LSASS dumps.
- **Enumerators:**  
  List users, files, or network resources for situational awareness.

---

### 6. Lateral Movement

- Use modules like `remote_process_exec.h`, `dcom_lateral.h`, and `smb_relay.h` to move laterally within a network.

---

### 7. Custom Task Manager (Execution & C2 Automation)

### 7. Custom Task Manager (Execution & C2 Automation)

The custom task manager functions as the operational core of command-and-control. It is responsible for receiving callbacks from agents, assigning tasking, handling execution techniques, and automating the collection and return of results. Unlike traditional single-function loaders, this module manages the full cycle of communication and execution.

- **Callback Handling and Validation:**  
  Each agent callback is received and parsed by the task manager. The data is validated to confirm session integrity, then associated with the correct operator or campaign context. This ensures that no rogue or spoofed callbacks interfere with operations. Metadata such as host details, process identifiers, and execution timestamps are logged for operator visibility.

- **Task Queue Management:**  
  Once validated, callbacks are checked against a structured task queue. Operators can push tasks such as payload execution, process injection, or file retrieval. The task manager prioritizes, schedules, and dispatches these tasks back to the agent. Task queues are dynamic and adaptive, enabling operators to reassign or cancel instructions without breaking session flow.

- **Execution Modules:**  
  The task manager integrates multiple in-memory execution techniques, abstracted as modular headers.  
  - `process_hollowing.h`: inject payloads into newly spawned processes while hiding under legitimate binaries.  
  - `dll_side_loading.h`: exploit trusted application DLL search paths to load malicious modules.  
  - `memory_loader.h`: decrypt and map payloads entirely in memory using reflective execution.  

  Based on operator selection, the task manager chooses the execution method, applies encryption/decryption routines, and pushes the payload into the correct process context.

- **Automation and Control Flow:**  
  The task manager automates key components of C2 operations. Payload preparation, encryption, and delivery occur transparently without requiring manual intervention at each step. Control flow is handled through structured state management, ensuring that execution tasks follow a predictable lifecycle:  
  1. Callback received.  
  2. Validation and logging performed.  
  3. Task assignment from operator queue.  
  4. Execution via selected module.  
  5. Result captured and encrypted.  
  6. Callback response sent back to the C2.  

- **Result Collection and Reporting:**  
  Responses from agents are captured in real time. Output is encrypted, compressed, and returned as structured callback data. The task manager then correlates results with their original task IDs, presenting them to the operator in an organized format. This ensures seamless end-to-end tracking of every command issued and every result received.

By centralizing callback handling, execution, and response automation, the custom task manager transforms payload execution from isolated steps into a repeatable workflow.

---

### 8. MalwareDevelopment

- **Anti-Analysis:**  
  Detect VMs, sandboxes, or debuggers before executing payloads.
- **API_Obfuscation:**  
  Use indirect syscalls and runtime obfuscation to evade static and dynamic analysis.
- **Binary_Modifications:**  
  Patch binaries, hide PE sections, or rewrite metadata for stealth.
- **DLL_SideLoading:**  
  Hijack trusted DLLs or modify exports for stealthy execution.
- **Network_Traffic_Evasion:**  
  Make C2 traffic look legitimate (HTTP, DNS, TLS) or use covert channels.
- **Process_Injection:**  
  Choose from APC injection, process hollowing, or reflective DLL injection.
- **Shellcode_Obfuscation:**  
  Mask shellcode as images, embed in C++ templates, or add junk bytes.
- **Steganography:**  
  Hide data in images, audio, or documents for exfiltration or staging.
- **String_Obfuscation:**  
  XOR or base64 encode strings to evade YARA and AV.
- **Windows_API:**  
  Dynamically resolve and call Windows APIs for flexibility and stealth.

---

## Example Workflow

1. **Select Modules:**  
   Decide which features you need (e.g., AV evasion, credential theft, lateral movement).

2. **Include Headers:**  
   In your main C++ project, include the relevant `.h` files.

3. **Initialize & Chain Functions:**  
   Call the functions in logical order (e.g., evade AV → inject shellcode → establish C2).

4. **Customize:**  
   Modify or extend modules as needed for your target or OPSEC.

5. **Build:**  
   Compile your project. The `Builds` directory can be used to store compiled payloads and binaries.

---

## Tips

- Test each module independently before combining.
- Use obfuscation and encryption modules to evade detection.
- Regularly update modules to keep up with new defenses.
- Document your build process for repeatability.

---

## Builds

- **Builds** — Store your compiled payloads & binaries here.

---
