# API Obfuscation
Function Obfuscation

Dynamically resolving functions


## Agenda
- Why obfuscate functions
- Runtime Linking
- API Hashing
- (whatever that technique is to point to a benign function)

# Why Obfuscate Function Calls

An analyst (or security product) can look at the Import Address Table (IAT) to get a list of functions used in the malware

The functions provide insight into the actions and overall goals of the code.

Common for malware to obfuscate or use additional techniques to prevent entries in the IAT in order to slow down static analysis


### Import Address Table Example

Viewing the IAT provides insights into Mimikatz’s functionality to export certificates

![Slide Image](../../assets/API_Obfuscation_images/slide4_img2.png)

![Slide Image](../../assets/API_Obfuscation_images/slide4_img3.png)



### PeStudio

PeStudio, and similar tools, will flag suspicious functions based on the IAT

![Slide Image](../../assets/API_Obfuscation_images/slide5_img2.png)


# Types of Linking
Static linking
- All code from a library is copied into the resulting binary

- Increased file size of final binary

Dynamic linking
- Searches for and loads libraries required when program loads or starts

- Information required about libraries is included in the PE header

- Follows the standard windows search order process

Runtime linking
- Load functions from libraries only when the function is needed

- Useful for preventing entries in the Import Address Table (IAT)
---

### Runtime Linking Function Prototype

Define the prototype for the function you want to use

Example: using WriteProcessMemoryPrototype = BOOL(WINAPI\*)(HANDLE, LPVOID, LPCVOID, SIZE\_T, SIZE\_T)

![Slide Image](../../assets/API_Obfuscation_images/slide7_img2.png)


## Runtime Linking Obtaining a Handle 

Get a handle to the library that contains the function you want to load

```LoadLibrary or GetModuleHandle are typically used
HANDLE hDLL = ::LoadLibrary(LPWSTR(L“kernel32.dll”));
       if (hDLL == NULL)
       {
  std::wcout << “LoadLibrary failed” << std::endl;
                 return hDLL;
       }
       return hDLL;
```

LoadLibrary will load a DLL from the filesystem whereas GetModuleHandle is used to find a DLL already loaded into the process. Both return the base address.


## Runtime Linking Steps - Resolving the address

Get the address of the function using GetProcAddress or similar function

Example:
```
WriteProcessMemoryProtoype WriteProcessMemory = (WriteProcessMemoryPrototype)(::GetProcAddress(hModuleHandle, LPCSTR("WriteProcessMemory")));
```

Call the function:
```
WriteProcessMemory(hProcess, memory, &scode, sizeof(scode), NULL)
```

## Run Time Linking Results

Analysis with PeStudio before applying runtime linking for thread hijacking

![Slide Image](../../assets/API_Obfuscation_images/slide10_img2.png)


## Run Time Linking Results

Analysis using PeStudio after applying runtime linking 

![Slide Image](../../assets/API_Obfuscation_images/slide11_img2.png)


## API Hashing

Another technique to obfuscate the actual functionality of the malware by preventing entries in the IAT

High level overview:
- Create a hash of the API/function name using a technique of the author’s choice
- Load or get a handle to the DLL containing the API/function
- Iterate through the Export Address Table (EAT), hash each function, then compare
- Return the virtual address of the function when found

Commonly seen across malware samples/families including Lokibot, Dridex, REvil, Zloader, PlugX, PoisonIvy, Carbanak ....


## API Hashing Example

Example hashing function using FNV and addition

The screenshot shows a function to calculate the hash of a string, which in this case would be the API name found in the EAT. FNV is used followed by the addition of a number, but this could be replaced by whatever algorithm the malware author would like to use.

![Slide Image](../../assets/API_Obfuscation_images/slide13_img2.png)



## API Hashing Example (continued)

Example of reading the EAT

The screenshot shows code to get the base address of the DLL passed as the first argument to the function, find the EAT, and then get the relevant addresses. Note, the code is based off the blog post at https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware

![Slide Image](../../assets/API_Obfuscation_images/slide14_img2.png)



## API Hashing Example (continued)

Example of searching for the target hash

The code then loops through the APIs, calculates their hash, and checks for a match (second argument passed to the function). If a match is found, the address of the function is returned so it may be called.

![Slide Image](../../assets/API_Obfuscation_images/slide15_img2.png)


## API Hashing Example (continued)

Example of calling the API hashing functionality shown on previous slides

Example of searching for and using the MessageBoxA API using the code from the previous slides.

![Slide Image](../../assets/API_Obfuscation_images/slide16_img2.png)

## API Hashing Code Issue

The issue with the proceeding code is still the call to LoadLibrary
This can be solved by the following:
- Find the Process Environment Block (PEB)
- Use the PEB to locate the InLoadOrderModuleList
- Search the InLoadOrderModuleList for Kernel32
- Iterate through the EAT of Kernel32 until we find a match for LoadLibraryW (or LoadLibraryA)

## API Hashing Code Improved

Finding the PEB and base address for Kernel32.dll

![Slide Image](../../assets/API_Obfuscation_images/slide18_img2.png)

![Slide Image](../../assets/API_Obfuscation_images/slide18_img3.png)


## Imphash

- The ordering of the entries in the IAT can be used to tie together samples
- When compiling the malware, the linker will generate the IAT based on the ordering of the functions used within the source
- Analyst can create a hash based on the APIs used and their ordering, which is known as the Imphash
- If a malware author changes the code but the ordering is not changed, the imphash may still allow an analyst to track and identify
- Removing the imports through the use of runtime linking or API hashing can help evade imphashing
- Inserting benign API/functions in the code could also be used to change the imphash

References:
https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html
https://malcomvetter.medium.com/defeating-imphash-fb7cf0183ac


## API Hashing Code Improved

Using the returned address for LoadLibrary to load DLLs

![Slide Image](../../assets/API_Obfuscation_images/slide20_img2.png)


## Call Obfuscation

Call obfuscation is a technique used by malware authors to further hinder static and dynamic analysis by making it more difficult to trace or recognize function calls. Instead of calling APIs directly, malware may:

- Use indirect calls through function pointers or calculated addresses.
- Employ control flow obfuscation, such as inserting junk instructions or opaque predicates.
- Leverage return-oriented programming (ROP) or call stack manipulation to invoke APIs.
- Inline or dynamically generate shellcode to perform API calls.
- Use custom stubs or wrappers that disguise the real API being called.

These techniques can defeat signature-based detection and frustrate analysts trying to reconstruct the malware’s behavior. Combined with runtime linking and API hashing, call obfuscation can make reverse engineering significantly more challenging.

**Example Techniques:**
- Calling APIs via pointers stored in variables, rather than by name.
- Using assembly instructions like `jmp`, `call`, or `push`/`ret` sequences to obscure the call origin.
- Encrypting or encoding the call sequence, only decoding at runtime.

**Purpose:**  
- Evade detection by static analysis tools and sandboxes.
- Break automated tools that rely on recognizable call patterns.
- Change the imphash by altering the call structure or inserting benign calls.


References:
https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html
https://malcomvetter.medium.com/defeating-imphash-fb7cf0183ac


