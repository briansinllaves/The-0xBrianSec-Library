# Hashing


## What is hashing 

Hashing is the process of scrambling a piece of information or data beyond recognition. They are designed to be irreversible. We pass the input through a hash function to calculate the hash value or digest.

## CRC32

- Cyclic Redundancy Check (CRC), 32 bit
-CRC32 is often used for error checking

## DJB2

- Original version written in 1991 to be a simple hashing function for strings
- The hashing function begins by setting the hash variable to the number 5381
- It then iterates each character, performing the following:
    - Multiply the hash variable by 33 using bit shifts (done for speed)
    - Adds the ASCII value of the character
A second variation of djb2 using xor is also commonly seen
```
    hash(i) = hash(i - 1) \* 33 ^ str[i];
```

### Detection

DJB2 can be detected through the use of the constant values 33 and 5381, 

although other limited values may be used

**Malware usage:**  
DJB2 is commonly used by malware to obfuscate API names, strings, or configuration keys. By hashing these values, malware authors can hide sensitive information and make static analysis more difficult. Analysts often look for the characteristic constants (33 and 5381) to identify DJB2 usage in malicious code.

**Example:**  
Some malware families, such as PlugX and PoisonIvy, use DJB2 to hash Windows API function names. Instead of storing function names in plaintext, the malware stores their DJB2 hashes and resolves them at runtime by hashing exported function names from loaded modules and comparing the hashes.

*Example pseudo-code for API resolution using DJB2:*
```cpp
// ...existing code...
DWORD djb2(const char* str) {
    DWORD hash = 5381;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    return hash;
}

// Example: resolve "LoadLibraryA" by hash
DWORD target_hash = 0x0726774C; // DJB2 hash of "LoadLibraryA"
for (each exported function in module) {
    if (djb2(function_name) == target_hash) {
        // Found the function
    }
}
// ...existing code...
```



![Slide Image](../../assets/Hashing_images/slide6_img2.png)

## MD5

- Designed in 1991 by Ronald Rivest
- One-way cryptographic hash function
- 128-bit digest size for every single input
- Initially designed for digital signatures
- MD5 is considered insecure due to cryptographic weaknesses


## SHA 

- Secure Hash Algorithms (SHA)
- SHA-1 is a cryptographic function which takes an input and produces a “message digest”, usually shown in hexadecimal format, of 160 bits
- SHA-2 refers to SHA-256 and SHA-512, which use 256 and 512 bits to produce the message digest
- SHA-3 uses a different internal structure than the previous SHA versions but still supports the same hash lengths
- SHA-1 is considered insecure due to cryptographic weaknesses



- **Malware usage:**  
Malware leverages SHA hashing (such as SHA-1 or SHA-256) to obfuscate strings, configuration data, or API names. By storing only the hash values instead of plaintext, malware authors make static analysis and reverse engineering more difficult. Some malware families use SHA hashes to verify the integrity of their code, check for tampering, or resolve function names dynamically at runtime by comparing computed hashes with stored values.

- ## **Detection:**  
Detection of SHA usage in malware can involve searching for known SHA algorithm constants, function patterns, or API calls (e.g., `CryptHashData`, `SHA1Init`, `SHA256Init`). Analysts may also look for code that processes data in 64-byte blocks or uses specific initialization vectors and round constants associated with SHA. Additionally, the presence of SHA-related libraries or imports in the binary can

Example code to create a SHA-1 hash of a string in C#


![Slide Image](../../assets/Hashing_images/slide9_img2.png)

## FNV-1 / FNV-1a

- Fowler-Noll-Vo (FNV) is a non-cryptographic hashing function
FNV-1 is easy to implement, provides good performance and has a low collision rate
- Suited for hashing strings such as URLs, addresses, filenames, etc.
- The only difference in implementation between FNV-1 and FNV-1a is the order of the xor and multiplication


- **Malware that uses FNV-1/FNV-1a:**  
FNV-1 and FNV-1a are used by various malware families to hash API names, configuration keys, or strings. Examples include the Dridex banking trojan and some variants of TrickBot, which use FNV-1a to obfuscate Windows API calls and evade static detection.

- **Detection:**  
Detection of FNV-1/FNV-1a usage can involve searching for the characteristic prime values and offset basis constants in code (e.g., 0x01000193 and 0x811c9dc5 for 32-bit). Analysts may also look for the specific multiplication and XOR patterns in disassembly, or identify custom hash functions that match the FNV algorithm. The presence of these constants or patterns in malware binaries can indicate the use of FNV hashing for

```

## Detection may be based on offset / prime values ???

Primes:
32 bit = 16777619 (0x01000193)
64 bit = 1099511628211
128 bit = 309485009821345068724781371
256 bit = 374144419156711147060143317175368453031918731002211
512 bit = 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759
1024 bit = 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573

offset_basis:
32 bit = 2166136261 (0x811c9dc5)
64 bit = 14695981039346656037
128 bit = 144066263297769815596495629667062367629
256 bit = 100029257958052580907070968620625704837092796014241193945225284501741471925557
512 bit = 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785
1024 bit =14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915

```

## FNV-1 / FNV-1a

Example FNV-1a implementation in C++

![Slide Image](../../assets/Hashing_images/slide11_img2.png)
