# Memory Obfuscation and Evasion

## Slide 1

Memory Obfuscation and Evasion

Subtitle

## Slide 2

Agenda

Memory allocations
Memory permissions
Controlling the originating thread
Patching
SetThreadContext
\_beginthreadex

## Slide 3

Memory allocation review

A process can manipulate the virtual memory of itself, or with the correct permissions, the memory of another process
Memory allocations can be performed using the following:
Virtual API: used for general memory management. Includes VirtualAlloc, VirtualProtect, VirtualFree, etc. These end up calling NtAllocateVirtualMemory.
Heap API: generally used for small allocations that are less than a page in size. Internally uses the Virtual API with additional management features added. Includes HeapAlloc, HeapCreate, HeapDestroy, HeapLock, etc
Memory-mapping: used to map files as memory or share memory between processes. Includes CreateFileMapping, OpenFileMapping, MapViewOfFile, etc
Compiler specific: language/compiler specific implementations such as malloc, realloc, free, new, delete, etc

**Speaker Notes:** References: Windows Internals 7th Edition, Part 1

## Slide 4

Memory allocation review

 Process memory falls under three categories:
Private Memory (MEM\_PRIVATE) - generic memory allocated using NtAllocateVirtualMemory (historically used by malware / offensive tools)
Mapped Memory (MEM\_MAPPED) - mapped files other than images. Files mapped in this manner may or may not be backed by a file on disk
Image Memory (MEM\_IMAGE) - mapped views of sections created with the SEC\_IMAGE flag from a file on disk (exe/DLL). Expected for PE files loaded by the OS

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide4_img2.png)

## Slide 5

Memory permissions

PAGE\_EXECUTE\_READWRITE (RWX) marks the memory as writable, readable and executable
This allows for code to be written, modify itself, and execute. RWX allocations are viewed as suspicious and best avoided
As a workaround to RWX, memory may be marked as PAGE\_READWRITE (RW), the code written to the memory space, then modified with NtProtectVirtualMemory to PAGE\_EXECUTE\_READ (RX) to allow for execution
This avoids RWX sections and the Virtual Address Descriptor table checked by some memory forensics tools will show RW even after modifying to RX
Scanning of memory can be an expensive process, so the characteristics (e.g. MEM\_IMAGE vs MEM\_PRIVATE) and permissions are often used to determine what memory is scanned

## Slide 6

Memory opsec considerations

Opsec considerations:
Avoid RWX allocations whenever possible. If required, look for processes with RWX memory sections already present (example: SMSvcHost.exe)
Attempt to mimic the expected permissions for each section if applicable (e.g. text section should be RX, data section RW, etc.)
MEM\_IMAGE allocations backed by a file on disk are generally seen as less suspicious
Memory containing artifacts, such as shellcode, encryption keys, domain names, etc. should be cleared when no longer required
Break up shellcode or other large allocations as the size of the allocation maybe a consideration for identifying suspicious memory regions. The default page size on x64 is 4kB, so allocating in chunks of 4kB may be a viable option for blending in

## Slide 7

Enumerating process memory for permissions

Example if enumerating memory permissions for running processes to identify private memory with RWX permissions

**Speaker Notes:** CreateToolhelp32Snapshot is used to grab a snapshot of the currently running processes. The code then attempts to call OpenProcess to get a handle for each process. VirtualQueryEx is used to query the process and then a check is done for RWX memory that was allocated as private. Note, the call to OpenProcess may fail if the code is not ran in an elevated context or the process is protected.

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide7_img2.png)

## Slide 8

Specifying the originating thread location

The traditional usage of CreateRemoteThread to execute shellcode in another process will cause a thread to be executed that is not originating from an expected module/function not backed by a file on disk
This indicator may be used by security products to identify suspicious code executing in memory
Sample methods to avoid the indicator:
Modify the prologue of a function expected to create a thread to jump to the shellcode
Spawn a suspended thread with the start address at a chosen function, modify the instruction pointer of the thread to point to the shellcode, then resumes the thread
Replacing CreateRemoteThread with QueueUserAPC
Using \_threadstartex for creating a thread locally
This will result in the thread originating from an expected function/module

## Slide 9

Specifying the originating thread location

The screenshot below shows a new thread being created using CreateRemoteThread to execute shellcode at the memory address 0x12437f100. Note the thread originates from memory that points to the shellcode

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide9_img2.png)

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide9_img3.png)

## Slide 10

Specifying the thread location using patching

Example code to patch a function with a jump to attacker allocated memory. This will cause the thread to originate from a function within a module such as ntdll

**Speaker Notes:** The code finds the address to the function to patch, which in this case is RtlpWow64CtxFromAmd64 in ntdll. The patch is then adjusted to account for the location of the shellcode/code which is passed into the function as a parameter (targetMemoryAddress). The target function prologue is then overwritten with the patch, which will cause a jump to the shellcode/code when called. Finally, CreateRemoteThread is used to start execution at the patched function, which cause the thread executing the shellcode/code to originate from the specified function/module.


References:
https://blog.redbluepurple.io/offensive-research/bypassing-injection-detection
https://github.com/forrest-orr/artifacts-kit/blob/master/ArtifactsKit/Console.cpp

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide10_img2.png)

## Slide 11

Specifying the thread location using patching

The target function has been patched with a jump to the memory address containing our code

**Speaker Notes:** A breakpoint is placed on the target function in the process we are injecting into, which is notepad in this example. After writing the patch, we can see the change to the function prologue. RAX now holds our shellcode, which is just INT3 (\xCC) and NOP instructions (\x90) in this example.

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide11_img2.png)

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide11_img3.png)

## Slide 12

Specifying the thread location using patching

The result is the start address of the thread which executes the shellcode now originates from the target function, which is RtlpWow64CtxFromAmd64 in this case, instead of the memory location of the shellcode

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide12_img2.png)

## Slide 13

Specifying thread location with SetThreadContext

The address of the target function is found
A new thread pointing to the address of the target function is then created in a suspended state
GetThreadContext is used to find the current value of the instruction pointer for the suspended thread
The instruction pointer is then updated to point to the memory address of the code to be executed
SetThreadContext is then used to update the values and the thread is resumed using ResumeThread
This results in the thread being created from a function of our choosing backed on disk that then executes the code at the target memory address

**Speaker Notes:** Reference:
https://blog.xpnsec.com/undersanding-and-evading-get-injectedthread/

## Slide 14

Specifying thread location with SetThreadContext

Spawning a thread from a function and modifying with SetThreadContext

**Speaker Notes:** The address of the target function is found, which is RtlpWow64CtxFromAmd64 in NTDLL in this example. A new thread pointing to the address of the target function is then created in a suspended state. GetThreadContext is used to find the current value of the instruction pointer for the suspended thread. The instruction pointer is then updated to point to the memory address of the code to be executed. SetThreadContext is then used to update the values and the thread is resumed using ResumeThread. This results in the thread being created from a function of our choosing backed on disk that then executes the code at the target memory address.

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide14_img2.png)

## Slide 15

Specifying thread location with SetThreadContext

The thread that executes the shellcode is started from the RtlpWow64CtxFromAmd64 function within NTDLL

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide15_img2.png)

## Slide 16

Specifying thread location with \_beginthreadex

\_beginthreadex accepts multiple parameters including the start address of a routine to execute as a new thread, and the arguments to pass to the new thread
The function then calls \_threadstartex in msvcrt.dll in order to create the new thread
The thread’s entry point will originate from msvcrt.dll, bypassing checks to ensure the thread is backed by a file on disk
This technique will not work for remote process injections

**Speaker Notes:** Reference: https://www.trustedsec.com/blog/avoiding-get-injectedthread-for-internal-thread-creation/

## Slide 17

Leveraging QueueUserAPC

The

**Speaker Notes:** Reference:
https://rastamouse.me/exploring-process-injection-opsec-part-2/

## Slide 18

Thread Stack Spoofing

The

**Speaker Notes:** Reference:
https://github.com/hasherezade/pe-sieve/wiki/4.9.-Scan-threads-callstack-(threads)

## Slide 19

Thread Stack Spoofing

The

**Speaker Notes:** Reference:

## Slide 20

Image and process notifications

MS provides the ability to register callbacks that will be executed upon the creation of a process and/or thread
Examples include PsSetCreateProcessNotifyRoutineEx, PsSetCreateThreadNotifyRoutineEx, and PsSetLoadImageNotifyRoutine
Once the callback is triggered, actions such as scanning memory may be performed
Note, the callbacks are not actually invoked until the first thread in the process is created

**Speaker Notes:** 

## Slide 21

Bypassing load notifications

M

**Speaker Notes:** 

## Slide 22

Overwriting the PE header

Overwriting/erasing the PE header may be done to obfuscate a PE in memory
Bypasses memory scanners that look for the magic value “MZ”
Also serves as an anti-analysis technique as the dumped memory image would be missing items such as the addresses of various tables and the entry point
Used in frameworks such as Cobalt Strike and ….

**Speaker Notes:** Add malware that erases pe header

## Slide 23

Mirroring a PE header

Overw

**Speaker Notes:** Add malware that erases pe header

## Slide 24

Overwriting the PE header

Clearing the DOS header from memory. The same process of adjusting memory permissions/overwriting needs to occur for the NT Header

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide24_img2.png)

## Slide 25

Overwriting the PE header

The top image shows the PE header before the overwrite and the image below shows the result after execution

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide25_img2.png)

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide25_img3.png)

## Slide 26

Obfuscating functions 

Functions can be obfuscated in memory when not required to assist in evading memory scanning
Process flow:
Get the address in memory of the function to obfuscate
Calculate the size of the function
If necessary, change the memory permissions to allow writes
Obfuscate the function
Revert changes to memory permissions (optional)
Calculating the size of the function can be done by searching for a marker at the end of the function
Examples of malware/frameworks using function/data obfuscation include Cobalt Strike and Smoke Loader

**Speaker Notes:** References:
https://gurhanpolat.medium.com/calculate-c-function-size-x64-x86-c1f49921aa1a
https://cert.pl/en/posts/2018/07/dissecting-smoke-loader/#function-body-encryption

## Slide 27

Obfuscating functions 

The following example shows the creation of a macro for a inserting the marker that is used to determine the size of the function
\_\_debugbreak() is equivalent to \xCC (INT3/breakpoint instruction). This can be modified as required for another pattern

**Speaker Notes:** References:
https://gurhanpolat.medium.com/calculate-c-function-size-x64-x86-c1f49921aa1a

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide27_img2.png)

## Slide 28

Obfuscating functions 

A search is then performed for the marker and the size returned

**Speaker Notes:** References:
https://gurhanpolat.medium.com/calculate-c-function-size-x64-x86-c1f49921aa1a

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide28_img2.png)

## Slide 29

Obfuscating functions 

Within the function to encrypt, a volatile variable is defined in order to prevent the compiler from optimizing out the marker

**Speaker Notes:** References:
https://gurhanpolat.medium.com/calculate-c-function-size-x64-x86-c1f49921aa1a

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide29_img2.png)

## Slide 30

Obfuscating functions 

The address of the function can be determine in C++ in the following manner, where FuncToEncrypt is the target function:
void\* funcToEncryptAddress = FuncToEncrypt;
Once the address and size of the function is known, VirtualProtect or similar can be used to change the permissions of memory and then reverted once obfuscation is completed
Obfuscation/encryption can then be performed. The screenshot below shows a simple XOR on the function

**Speaker Notes:** 

![Slide Image](../../assets/Memory_Obfuscation and Evasion_images/slide30_img2.png)

## Slide 31

Gargoyle

**Speaker Notes:** 

## Slide 32

Stage vs Stageless shellcode

**Speaker Notes:** 

## Slide 33

Lab

C

