# Encryption

## Slide 1

Encryption

Insert subtitle

## Slide 2

Agenda

Why use encryption
Encryption fundamentals
Encryption using windows APIs
AES
RC4
TEA
MISTY1
Avoiding magic values
Case Study
Lab

## Slide 3

Why use encryption 

Encryption refers to the “transformation of data into a form that conceals the data’s original meaning to prevent it from being known or used” - NIST
Uses of encryption in malware include:
Obfuscation of sensitive data
Signature based evasion
Slowing down the analysis process
Render data inaccessible

## Slide 4

Encryption fundamentals 

Symmetric algorithms use the same key for encryption and decryption
Asymmetric algorithms use two keys, one for encryption and one for decryption
In asymmetric, the two keys are referred to as the public key, which is shared, and the private key
Encryption keys depend upon the algorithm being used, but tend to either be static or dynamically modified during execution

**Speaker Notes:** Reference: Mastering Malware Analysis by Alexey Kleymenov and Amr Thabet

## Slide 5

Encryption modes 

CBC
CFB
OFB
….

**Speaker Notes:** Modes and if they add padding, etc

## Slide 6

Encryption using windows APIs 

Microsoft offers two sets of APIs/functions that are used for encryption
The legacy set is referred to as the CryptoAPI
Cryptography API: Next Generation (CNG) is a replacement for CryptoAPI
Common process flow for CNG
Open the algorithm provider using BCryptOpenAlgorithmProvider (providers are libraries for crypto)
Get or set any properties such as the key size or mode of operation with BCryptGetProperty and BCryptSetProperty
Create or Import a key (BCryptGenerateSymmetricKey, BCryptGenerateKeyPair, BCryptImportKey, BCryptImportKeyPair)
Encrypt or decrypt using BCryptEncrypt or BCryptDecrypt
Close the algorithm provider using BCryptCloseAlgorithmProvider
CNG supports multiple symmetric, asymmetric, hashing and key exchange algorithms

## Slide 7

AES

Advanced Encryption Standard (AES)
Symmetric-key algorithm
Fixed block size of 128 bits and a key size of either 128, 192 or 256 bits
Approved standard for the US government by the National Institute of Standards and Technology (NIST)
Chosen by NIST for performance on a variety of hardware and software components, ease of implementation and level of security provided
Popular with malware authors
PyFlash (Turla) - Encrypt C2 traffic
MATA - Loader decrypts AES encrypted payload
ModPipe - Encrypt C2 traffic with AES in CBC mode
Phobos Ransomware - AES encryption of strings and other data
Cobalt Strike - Part of the tasking process (AES/HMAC)

## Slide 8

RC4

**Speaker Notes:** Add malware using AES

## Slide 9

TEA

Tiny Encryption Algorithm (TEA)
Designed to have a simple description and implementation
Encrypts 64 bit blocks using a 128 bit key
Suffers from equivalent keys, which means each key is equivalent to three others. This effectively reduces the key size to 126 bits
TEA is vulnerable to related-key attacks
To address the weaknesses, variations (XTEA and XXTEA) were developed
TEA may be identified by the magic value 0x9e3779b9
When using TEA to encrypt files/strings, keep in mind that it operates on 64 bit blocks (8 bytes) at a time. This means you will have to read in the file/string 8 bytes at a time and account for padding

**Speaker Notes:** Add malware using TEA

## Slide 10

TEA

Public domain code example of encryption and decryption using TEA

**Speaker Notes:** 

![Slide Image](../../assets/Encryption_images/slide10_img2.png)

## Slide 11

MISTY1

Block cipher developed for Mitsubishi Electric
Operates on 64 bit blocks with a key size of 128 bits and a variable number of rounds
Secure against differential and linear cryptanalysis
Designed for performance on hardware platforms and software environments
Used by Turla in their Outlook backdoor

**Speaker Notes:** Malware using misty1 - add reference
Identifying the use of misty1

## Slide 12

Avoiding magic values

Encryption algorithms often contain a “magic value”, which is a constant associated with the process
A malware analyst can look for the constants in order to identify the algorithm
Tools that automate the process include Krypto ANALyzer (KANAL) and FindCrypt2 (IDA Pro plug-in)
By calculating the constant at execution, tools that search for the magic value may be bypassed
Opaque predicates are useful to create a situation in which the outcome is known ahead of time but the expression still needs to be evaluated at execution
Opaque predicates can be used as part of the calculation of the magic value

**Speaker Notes:** More on opaque predicates later

## Slide 13

Avoiding magic values

Using Krypto ANALyzer (KANAL) to detect the use of TEA

**Speaker Notes:** Malware using misty1
Identifying the use of misty1

![Slide Image](../../assets/Encryption_images/slide13_img2.png)

## Slide 14

Avoiding magic values

An opaque predicate is used to calculate the value of the constant need. KANAL is no longer able to identify a crypto signature after the change

**Speaker Notes:** Malware using misty1
Identifying the use of misty1

![Slide Image](../../assets/Encryption_images/slide14_img2.png)

## Slide 15

Case Study

Case study on some malware using encryption (ransomware / wipers)

**Speaker Notes:** oad.html

## Slide 16

Lab

Encrypt things

