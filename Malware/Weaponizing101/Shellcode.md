# Shellcode

## Overview

- What is shellcode
- Writing position independent code with VS

## What is shellcode.

- Shellcode is position independent code
- Position independent code is code that can be executed in memory at any address without requiring modification, such as the need to align the stack
- When delivering shellcode, an exploit developer can not guarantee where the code will reside in memory
- For malware authors, shellcode may be used for initial staging or in-memory execution

## Position independent code.

- General guidance for achieving position independent code (PIC):
	- Cannot use addresses or reference data from other execution sections
	- Addresses references must be relative to the current instruction pointer
	- Code must be written so no relocations are required
	- Avoid the use of static libraries
	- Avoid the use of global and static variables

## Writing PIC.

- Objective
	- Write x64 PIC code that can be extracted from the .text section of an executable
- Approach
	- Resolve all imports during runtime
	- Avoid the use of strings or other data that would be stored outside the text section
	- Align the stack to account for x64
	- Replace mainCRTStartup with a custom entry point
	- Extract opcodes from the resulting text section and executed in memory

## Finding modules.

- For a PE loaded by the OS, the import address table will handle the resolving of all the APIs required
- In this case, there is no import address table so the APIs will need to be manually resolved
- The process environment block (PEB) contains a list of DLLs loaded in the process address space in the InMemoryOrderModuleList structure
- Search the structure until the base address for kernel32 or ntdll is found

## PEB.

- The PEB is created at process runtime: __readgsqword(0x60)
- The Ldr (PEB_LDR_DATA structure) contains a doubly-linked list of the loaded modules (InMemoryOrderModuleList)
- InMemoryOrderModuleList is a LIST_ENTRY structure composed of the Flink and Blink
- The TEB points to the PEB at offset 0x60 in x64 or offset 0x30 in x86
- In x64, the GS register can be used to get the peb, and similarly the FS register may be used for x86

![Slide Image](../../assets/Shellcode_images/slide7_img2.png)

## Locating modules.

- Example of finding kernel32
- Kernel32 can then be used to locate other functions that are required
- References:
	- https://vxug.fakedoma.in/papers/VXUG/Exclusive/FromaCprojectthroughassemblytoshellcodeHasherezade.pdf
	- https://github.com/paranoidninja/PIC-Get-Privileges/blob/main/addresshunter.h
	- https://www.ired.team/offensive-security/code-injection-process-injection/writing-and-compiling-shellcode-in-c

![Slide Image](../../assets/Shellcode_images/slide8_img2.png)

## Finding function addresses.

- Walk the exports table of kernel32 or ntdll in order to find LoadLibrary/LdrLoadDll and GetProcAddress/LdrGetProcedureAddress
- Note, this can be replace with custom versions instead if monitoring/hooking is a concern
- The export table is contained in the Data Directory of the target module
- Loop through the export table searching functions by name, get the relative virtual address (RVA), and add that to the module base to find the address of the target function
- LoadLibrary and GetProcAddress can then be used to load the required DLLs and retrieve function addresses

## Finding functions.

![Slide Image](../../assets/Shellcode_images/slide10_img2.png)

- Reference: https://vxug.fakedoma.in/papers/VXUG/Exclusive/FromaCprojectthroughassemblytoshellcodeHasherezade.pdf

## Example code.

- The code follows the process outlined above and then resolves the required functions to print to the console

![Slide Image](../../assets/Shellcode_images/slide11_img2.png)


![Slide Image](../../assets/Shellcode_images/slide12_img1.png)

## Compiling to assembly.

- Start the dev console for visual studio (2022 enterprise): cmd /k "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat"
- Compile by changing into the directory with cpp file then do the following: “C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.34.31933\bin\Hostx64\x64\cl.exe” /c /FA /GS- file.cpp

	- /c = compiles without linking
	- /FA = Configures an assembly listing file
	- /GS- = Disable check of buffer security

## Assembly modifications.

- Open the resulting assembly file and remove the following lines:
	- INCLUDELIB LIBCMT
	- INCLUDELIB OLDNAMES
- Remove all pdata and xdata blocks

![Slide Image](../../assets/Shellcode_images/slide14_img2.png)

## Assembly modifications (align stack).

- Under the _TEXT SEGMENT label, add the following assembly which will align the stack on x64 systems
	```
     AlignRSP PROC
	 push rsi ; Preserve RSI since we're stomping on it
	 mov rsi, rsp ; Save the value of RSP so it can be restored
	 and rsp, 0FFFFFFFFFFFFFFF0h ; Align RSP to 16 bytes
	 sub rsp, 020h ; Allocate space
	 call main ; Call the entry point
	 mov rsp, rsi ; Restore the original value of RSP
	 pop rsi ; Restore RSI
	 ret ; Return to caller
	 AlignRSP ENDP
    ```
- Reference: 
	- https://github.com/mattifestation/PIC_Bindshell/blob/master/PIC_Bindshell/AdjustStack.asm

## Assembly modifications

- Adding the assembly to align the stack

![Slide Image](../../assets/Shellcode_images/slide16_img2.png)


- Reference: 
	- https://github.com/mattifestation/PIC_Bindshell/blob/master/PIC_Bindshell/AdjustStack.asm



## Assembly modifications (gs deref).

- Modify the line mov rax, QWORD PTR gs:96 to mov rax, QWORD PTR gs:[96]

![Slide Image](../../assets/Shellcode_images/slide17_img2.png)

## Linking

- Compile into an executable with the entrypoint modified
- "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.32.31326\bin\Hostx64\x64\ml64.exe" file.asm /link /entry:AlignRSP

![Slide Image](../../assets/Shellcode_images/slide18_img2.png)

## Extracting opcodes

- Open the executable in COFF Explorer or similar
- Right click on the opcodes in the bottom window and select all
- Copy into a new file

![Slide Image](../../assets/Shellcode_images/slide20_img2.png)

## Formatting opcode.

- Format the resulting opcodes as required for the injection method

- Example powershell to format to \x41\x42…

```
$var = 564600 # extracted opcodes
$temp = ([regex]::matches($var, '.{1,2}') | %{$\_.value}) -join '\x'
 Write-Output "\x$temp"
```
## Execution

- The resulting PIC can then be injected into memory

![Slide Image](../../assets/Shellcode_images/slide22_img2.png)
