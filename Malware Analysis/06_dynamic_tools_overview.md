# Dynamic Analysis Tools Overview

## Overview
Dynamic analysis profiles **real execution** to observe filesystem, registry, process, and network behaviors. The objective is to turn noisy runtime activity into **deterministic, repeatable findings** you can pivot on for detection, triage, and reporting.

## Lab Baseline (Recommended)
- **Isolated VM** (e.g., FLARE-VM or clean Win10) with snapshots.
- **Host-only network** or **INetSim** for safe C2 emulation.
- Packets captured to **PCAP**; events logged to **EVTX** and **Sysmon** (if permitted in your lab).
- Clock sync disabled to catch timing-based evasion and sleeps.

## Primary Tooling & What to Watch
| Tool | Role | Watch For |
|---|---|---|---|
| Procmon (Sysinternals) | File/Reg/Process events | Drops, renames, deletes, Run/Services keys, ADS writes |
| Process Explorer / Hacker | Process tree, handles, loaded modules | Suspicious parents, transient children, unexpected DLLs |
| API Monitor | API-level behavior | Network init, process creation, registry ops |
| TCPView / Netstat | Live sockets | Beacon cadence, ephemeral ports, listening sockets |
| Wireshark | Packet capture | DNS queries, HTTP(S) requests, odd headers/URIs |
| INetSim | Fake internet | Outbound HTTP/FTP/SMTP to known URIs |

## Analyst Workflow
1. **Snapshot** the VM; start **Procmon** (drop default filters) and **Wireshark** (capture all interfaces).
2. **Detonate** the sample once. Let it settle (30–120s).
3. **Freeze** execution if needed, then save:
   - Procmon PML, Wireshark PCAP, full memory snapshot (if you use a memory tool).
4. **Slice the noise**:
   - Procmon filters that commonly help:
     - `Process Name is <sample.exe>` or the PID observed
     - `Operation is WriteFile OR CreateFile OR RegSetValue`
     - `Path contains \Run\ OR \RunOnce\ OR \Services\`
   - Export filtered CSV for notes and later diffing across runs.
5. **Correlate** Procmon events with **process tree**: which parent spawned which child, what arguments, and when.
6. **Pivot to network**: match timestamps in PCAP to creation of sockets in Procmon, confirm domain/IP/URI and cadence.
7. **Re-run** with **API Monitor** only if needed (it can alter timing and break samples). Hook high-signal categories (Wininet/WinHTTP, Process/Thread, Registry).

## Outputs You Should Capture
- **Dropped paths + hashes** (record each new file created or modified).
- **Persistence keys** (registry paths, service/task names).
- **Command-lines** used to spawn interpreters (PowerShell, cmd, mshta, wscript).
- **Domains/IPs/URIs**, User-Agent strings, JA3/JA3S (if applicable).
- **Beacon timing** (jitter, backoff).

## Common Pitfalls
- Over-filtering Procmon too early; start broad, then narrow.
- Forgetting to capture **ParentCommandLine**—it explains “how” execution happened.
- Running multiple heavy tools simultaneously (e.g., API Monitor + Debugger) can change behavior.


## Additional Analyst Context
Practical malware analysis is not just about observing artifacts in isolation, but about **building narratives**. 
For every string, header anomaly, network request, or parent-child process chain, ask: 
what capability is being enabled, what objective is being pursued, and how does this align to known attacker tradecraft? 
For example, when analyzing persistence, note not just the registry key created but also the attacker’s likely intent 
to survive reboots. When analyzing network traffic, document whether it aligns to a beaconing pattern or a one-time 
file download. Building this contextual storyline turns low-level indicators into actionable intelligence for defenders 
and reproducible techniques for red teams.


## Advanced Perspective
Beyond tactical findings, always consider the **strategic implications** of what you observe. 
A packed binary is not simply an annoyance, it reflects the operator’s OPSEC awareness and desire to resist automated detection. 
A reverse shell connection to a hard-coded IP may reveal a less sophisticated adversary, while beaconing with domain generation 
algorithms implies higher maturity. Disassembly that shows anti-debugging tricks demonstrates both capability and intent to 
delay analysts. By recording these layers of detail, you can not only document what the malware does, but infer the adversary’s 
skill level, resources, and potential affiliations. This elevates your reporting from technical to intelligence-grade insight.
