    The first argument after BaitAndSwitch.exe specifies the symlink that will be monitored. Since the tool will create this for you, it's identified as the path where the program will try to create 12345.txt.
    
    The second argument is the initial target of the symlink, which is the same 12345.txt file within the waapi-exploit directory. This might seem redundant, but it aligns with the command structure where you specify the symlink's initial target. It's part of setting up the tool and does not necessarily mean manually placing a file at this location.
    
    The third argument is the path to the malicious file (stuff.txt) you want to switch to, located in the stuff directory.
    
    The final argument, d, signifies that the oplock should trigger on a delete operation, aligning with the file operation your vulnerable program performs on 12345.txt.
    
```
BaitAndSwitch.exe C:\Users\Tester\AppData\Local\Temp\waapi-exploit\12345.txt C:\Users\Tester\AppData\Local\Temp\waapi-exploit\12345.txt C:\Users\Tester\AppData\Local\Temp\stuff\stuff.txt d

```


Running a program as an administrator does not automatically grant it SYSTEM integrity level; it simply runs with elevated privileges compared to a standard user. The SYSTEM account has a higher level of access than a regular administrator account, often used by Windows services and system processes.

If you need your C++ program to run with SYSTEM integrity, you generally have two approaches:

    Run it as a Service: Windows services can run under the SYSTEM account, granting them high-level privileges. You would need to create a service that executes your program. This can be done using tools like sc.exe or configuring it through the Windows Services Manager.

    Use a Task Scheduler: The Windows Task Scheduler allows you to create tasks that run with the SYSTEM privileges. You can schedule a task to run your program once or on some recurring basis.

Running Your Program as a Service

To convert your program to run as a service, you would need to adjust your code to handle service-specific callbacks and registration. This involves using the Windows Service API to manage the lifecycle of your service (start, stop, pause, continue). This might be more complex than what you're looking for if you're not familiar with Windows services programming.
Using Task Scheduler to Run with SYSTEM Privileges

A more straightforward approach might be to use the Task Scheduler, as it does not require changing your program. Here's how you can set it up:

    Open Task Scheduler: Search for "Task Scheduler" in the Start menu and open it.

    Create a New Task: Go to Action > Create Task...

    Configure the Task:
General Tab: Give your task a ne and select "Run whether user is logged on or not". Check "Run with highest privileges". Change the "Configure for:" dropdown to your Windows version. Click on "Change User or Group" and type SYSTEM to run the task as the SYSTEM account.

Triggers Tab: Click "New..." and set your trigger based on when you want the program to run.
        Actions Tab: Click "New..." and browse to select your compiled
        executable. Add any arguments if needed.
        
Conditions and Settings Tabs: Adjust these based on your specific needs.
	
Save and Test Your Task: Once configured, you can run the task manually to test it or wait for the trigger condition to occur.


to practice other file operation techniques with BaitAndSwitch, you would indeed modify the section of your C++ prodx program that handles file operations. Currently, your program focuses on creating, writing to, and then deleting a file


code 2.1

```

//lab program

#include <iostream>
#include <filesystem>
#include <fstream>
#include <regex>
#include <chrono>
#include <thread>

nespace fs = std::filesystem;

int main() {
    std::string targetDir = "C:\\Users\\Tester\\AppData\\Local\\Temp";
    std::regex pattern("waapi-.*"); // Regex to match directories starting with 'waapi-'
    bool folderFound = false;

    for (const auto& entry : fs::directory_iterator(targetDir)) {
        if (entry.is_directory() && std::regex_match(entry.path().filene().string(), pattern)) {
            std::cout << "Found matching folder: " << entry.path() << std::endl;
            folderFound = true;

            std::string filePath = entry.path().string() + "\\12345.txt";

            std::ofstream file(filePath);
            if (file.is_open()) {
                file << "Béisbol es muy popular en países de habla hispana. Hay muchos equipos y jugadores famosos.";
                file.close();
            }

            // Set file permission for anyone to modify or access
            fs::permissions(filePath, fs::perms::all, fs::perm_options::add); // Adding universal access permissions to the file

            // Read from the file
            std::ifstream inputFile(filePath);
            if (inputFile.is_open()) {
                std::string content((std::istreambuf_iterator<char>(inputFile)), (std::istreambuf_iterator<char>()));
                std::cout << "File content: " << content << std::endl;
                inputFile.close();
            }

            // Wait for a specified time to allow oplock to be applied
            std::this_thread::sleep_for(std::chrono::seconds(5)); // Delay for 5 seconds before deletion

            // Delete the file
            if (fs::remove(filePath)) {
                std::cout << "File " << filePath << " deleted successfully." << std::endl;
            }

            break;
        }
    }

    if (!folderFound) {
        std::cout << "No matching folder found." << std::endl;
    }

    return 0;
}

```


