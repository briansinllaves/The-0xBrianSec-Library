Note
***NOTE
in Windows, when a COM object is instantiated, the system will first check for the CLSID under the HKEY_CURRENT_USER\Software\Classes\CLSID\ registry path before it checks the HKEY_CLASSES_ROOT\CLSID\ path. This behavior is part of the Windows Registry hierarchy where user-specific settings (those under HKEY_CURRENT_USER) typically take precedence over system-wide settings (those under HKEY_CLASSES_ROOT and HKEY_LOCAL_MACHINE).

Understanding Registry Lookup for COM Objects
HKEY_CURRENT_USER (HKCU): This hive stores settings that are specific to the logged-in user. When a COM class is registered here, it only affects the current user. This is typically the first place the system looks when resolving a CLSID to its associated COM server.

HKEY_CLASSES_ROOT (HKCR): HKCR is a merged view of HKEY_LOCAL_MACHINE\Software\Classes and HKEY_CURRENT_USER\Software\Classes. Entries in HKCU take precedence over HKLM when there is a conflict. HKCR is primarily a convenience hive that presents a view of both user-specific and system-wide class registrations, making it appear as a single unified registry tree.

InprocServer32
InprocServer32 hijacking targets the InprocServer32 registry key, which specifies the DLL that should be loaded as the in-process server for a COM class; by modifying this key to point to a malicious DLL, an attacker can execute arbitrary code when the application loads the COM class

ProgID
A ProgID hijack involves redirecting a Programmatic Identifier (ProgID) in the registry to point to a different CLSID, effectively causing any software that refers to the ProgID to load an unintended COM object. This type of hijacking is typically used to substitute a legitimate application component with a malicious one, leveraging the original ProgID as the entry point.

does not have strong integrity checks on the path or binary it executes.

Step 1 enum:
ProcMon setup
Set a filter for Operation is RegQueryValue to capture attempts to read registry values.
Path contains ProgID, HKEY_CURRENT_USER\Software\Classes\, NAME NOT FOUND

Step 2 Create the ProgID in the Registry

Step 3. Link the ProgID to a CLSID or a new one:
Under the newly created ProgID key, create a default value that points to a CLSID
You can either use an existing CLSID, that can be modified or is hijackable or create a new one. 

If creating a new CLSID, ensure it is also properly set up in the registry to link to your desired executable or DLL
Generate a Unique CLSID:use PowerShell: (New-Guid).Guid

Create a new key named with your newly generated GUID

Configure the Key:

Inside your new CLSID key, create either an InprocServer32 or LocalServer32 subkey.
Set the default value of this subkey to the full path of your executable or DLL.
Optionally, set the ThreadingModel for InprocServer32 if it's a DLL (common values are Apartment, Free, Both).

Example:
Suppose an application routinely queries for a ProgID named Example.Application. If this ProgID is not found:
Navigate to User-Specific Registry Path:

Open the Registry Editor (regedit).
Go to HKEY_CURRENT_USER\Software\Classes.
Create or Modify the ProgID:

If your target ProgID does not exist under HKEY_CURRENT_USER\Software\Classes, create it:
Right-click on Classes, select New > Key, and name it with your ProgID, for example, Example.Application.
Set the default value of this ProgID key to the CLSID you intend to use (e.g., {12345678-1234-1234-1234-1234567890AB}).
Generate and Set Up a New CLSID:

Under HKEY_CURRENT_USER\Software\Classes\CLSID, create a new key with the CLSID you want to use:
Right-click on CLSID, choose New > Key, and name it {12345678-1234-1234-1234-1234567890AB}.
Inside this new CLSID key, create a subkey for InprocServer32 or LocalServer32 depending on your payload type (DLL or EXE):
Right-click on your CLSID key, choose New > Key, and name it InprocServer32 or 

LocalServer32.
Set the default value of the InprocServer32 or LocalServer32 key to the path of your malicious executable or DLL, such as C:\Path\To\YourMaliciousCode.dll.
Optional Configuration:

For InprocServer32, you may also need to specify a ThreadingModel. Right-click on InprocServer32, choose New > String Value, name it ThreadingModel, and set its value to Apartment, Free, or Both.

LocalServer32

LocalServer32 hijacking occurs when an attacker changes the path specified in the LocalServer32 registry key (which normally points to the location of a COM server's executable) to the path of a malicious executable, causing applications that instantiate the COM object to run the attacker's code instead.
ProcMon setup
Set a filter for Operation is RegQueryValue to capture attempts to read registry values.
Path contains LocalServer32, HKEY_CURRENT_USER\Software\Classes\CLSID
NAME NOT FOUND

Run applications that are suspected of being involved in COM interaction
Perform typical operations within those applications to trigger COM object loading
exploiting via LocalServer32, replace the legitimate serverâ€™s executable path with the path to your malicious executable in the registry.



TreatAs
The TreatAs registry key is used to specify an alternative CLSID that should be treated as if it were the originally requested CLSID, effectively redirecting COM object creation to a different, possibly malicious, COM server without altering the original class registration. 
it doesn't preserve the functionality of the original CLSID in terms of what the application experiences, but rather it preserves the registry structure and entries of the original CLSID.
provides a unique strategic advantage in certain scenarios where direct modification of the original CLSID might be undesirable or more detectable. Like what?

Reduced Footprint: Altering the TreatAs key is less intrusive compared to changing LocalServer32 or InprocServer32 paths directly in the original CLSID
Strategic Use of TreatAs

Selective Hijacking: Because TreatAs allows the original CLSID to stay unmodified (except for the TreatAs addition), this method can be used strategically where a hijack is only desired under specific conditions or scenarios. For instance, a hijack could be activated by adding the TreatAs key only when certain users are logged in, or only on certain systems.
Reversibility and Clean-Up: Since the original registry entries aren't altered, removing the TreatAs key effectively ends the hijack, restoring the original COM instantiation behavior without needing to repair or recreate the original CLSID settings.


You first need to find a CLSID that is actively being called by applications. This means it should be a legitimate, existing CLSID that applications expect to interact with, not one that results in a "NAME NOT FOUND" error.

Step 1: Verify the Existence of the CLSID
check under HKEY_CURRENT_USER\Software\Classes\CLSID\.

Step 2: Add the TreatAs Key
Once you've identified a suitable CLSID, you add a TreatAs subkey under this CLSID in the registry. This subkey tells the COM system, "Instead of using this CLSID, treat it as though it were another CLSID.

Step 3.  Point TreatAs to a Hijackable CLSID:
The value of the TreatAs key should be the CLSID of another COM object that you can control or manipulate. This target CLSID should be one where you have added or can add malicious entries under ProgID, LocalServer32, or InprocServer32. These changes could point to a malicious DLL or executable that you want the system to load.


